## What is Object-oriented

Object-oriented programming (OOP) is a paradigm based on the concept of "objects". These objects can contain data, in the form of fields (also known as attributes or properties), and code, in the form of procedures (known as methods). OOP's main goals are to increase the flexibility and maintainability of code.
Key Concepts:

    Classes and Objects: Classes are blueprints for creating objects. An object is an instance of a class.

    Encapsulation: Bundling data and methods that operate on the data within one unit, like a class.

    Inheritance: Mechanism where one class can inherit the attributes and methods of another.

    Polymorphism: Ability to use a common interface for multiple forms (or data types).

    Abstraction: Hiding complex implementation details and showing only the necessary features of an object.


##  The representation of object concepts in the brain 

Evidence from functional neuroimaging of the human brain indicates that information about salient properties of an object-such as what it looks like, how it moves, and how it is used-is stored in sensory and motor systems active when that information was acquired. As a result, object concepts belonging to different categories like animals and tools are represented in partially distinct, sensory- and motor property-based neural networks. This suggests that object concepts are not explicitly represented, but rather emerge from weighted activity within property-based brain regions. However, some property-based regions seem to show a categorical organization, thus providing evidence consistent with category-based, domain-specific formulations as well. 

Our brain stores information about objects based on how we perceive and interact with them. For example, how an object looks, how it moves, and how we use it. Different types of objects, like animals and tools, are stored in different parts of the brain, which are linked to our senses and movements.
This means that our understanding of objects isn't stored as clear, distinct concepts. Instead, it emerges from the activity in these sensory and motor areas. However, some of these areas also seem to be organized by categories, supporting the idea that our brain organizes objects based on categories.

مغز ما اطلاعات مربوط به اشیاء را بر اساس نحوه درک و تعامل ما با آنها ذخیره می کند. به عنوان مثال، یک شی چگونه به نظر می رسد، چگونه حرکت می کند و چگونه از آن استفاده می کنیم. انواع مختلفی از اشیاء، مانند حیوانات و ابزار، در قسمت‌های مختلف مغز ذخیره می‌شوند که با حواس و حرکات ما مرتبط هستند.

این بدان معنی است که درک ما از اشیاء به عنوان مفاهیم واضح و متمایز ذخیره نمی شود. در عوض، از فعالیت در این نواحی حسی و حرکتی پدید می آید. با این حال، به نظر می رسد برخی از این مناطق نیز بر اساس دسته بندی ها سازماندهی شده اند، که از این ایده حمایت می کند که مغز ما اشیاء را بر اساس دسته بندی ها سازماندهی می کند.


https://pubmed.ncbi.nlm.nih.gov/16968210/


##  Faces, Bodies, Spiders, and Radios: How the Brain Represents Visual Objects 

Plato defined humans by two primary characteristics: no feathers and walking on two legs. This idea of reducing something to its key features is similar to principal component analysis (PCA) in modern terms. Researchers at Caltech found that our brains use a mathematical system to organize visual objects by their key features, creating a kind of map.

They discovered that different cells in our brain's visual system respond to different types of objects. For example, some cells respond to round objects like faces and apples, while others respond to spiky objects like helicopters and chairs. This forms a two-dimensional map in our brain where each cell's location is determined by the features of the objects it prefers.

Doris Tsao's lab has been studying how our brains recognize faces, and this new research shows that face recognition is part of a bigger map of object recognition. In the inferotemporal cortex (IT cortex), different regions process different types of objects, such as faces, bodies, and scenes.

Pinglei Bao, a postdoctoral scholar, discovered a new network in the IT cortex that responds to spiky objects. By using machine learning, Bao identified that certain features, like spikiness, are fundamental to how our brain categorizes objects. This aligns with the deep network's predictions, suggesting that our brain and AI systems might share similar mechanisms for recognizing objects.

افلاطون انسان را با دو ویژگی اصلی تعریف کرد: نداشتن پر و راه رفتن روی دو پا. این ایده کاهش چیزی به ویژگی های کلیدی آن شبیه به تجزیه و تحلیل اجزای اصلی (PCA) در اصطلاح مدرن است. محققان در Caltech دریافتند که مغز ما از یک سیستم ریاضی برای سازماندهی اشیاء بصری بر اساس ویژگی های کلیدی آنها استفاده می کند و نوعی نقشه ایجاد می کند.

آنها کشف کردند که سلول های مختلف در سیستم بینایی مغز ما به انواع مختلفی از اشیا پاسخ می دهند. به عنوان مثال، برخی از سلول ها به اجسام گرد مانند صورت و سیب پاسخ می دهند، در حالی که برخی دیگر به اجسام سیخ دار مانند هلیکوپتر و صندلی پاسخ می دهند. این یک نقشه دو بعدی در مغز ما تشکیل می دهد که در آن مکان هر سلول با ویژگی های اشیایی که ترجیح می دهد تعیین می شود.

آزمایشگاه دوریس تسائو در حال مطالعه این است که چگونه مغز ما چهره ها را تشخیص می دهد، و این تحقیق جدید نشان می دهد که تشخیص چهره بخشی از نقشه بزرگتر تشخیص اشیا است. در قشر inferotemporal (قشر IT)، نواحی مختلف انواع مختلفی از اشیاء را پردازش می کنند، مانند صورت، بدن و صحنه.

پینگلی بائو، محقق فوق دکترا، شبکه جدیدی را در قشر فناوری اطلاعات کشف کرد که به اجسام سیخ دار پاسخ می دهد. بائو با استفاده از یادگیری ماشینی متوجه شد که ویژگی‌های خاصی مانند تیز بودن، برای دسته‌بندی مغز ما از اجسام اساسی است. این با پیش‌بینی‌های شبکه عمیق مطابقت دارد و نشان می‌دهد که مغز و سیستم‌های هوش مصنوعی ممکن است مکانیسم‌های مشابهی برای تشخیص اشیا به اشتراک بگذارند.


https://www.caltech.edu/about/news/faces-bodies-spiders-and-radios-how-brain-represents-visual-objects


## Oop And Human Thought Process

Discussion based on an item listed under ArgumentsAgainstOop.

OOP does not model the human mind. The human mind is delightfully capable of holding many 'views' or 'models' of our perceptions at once - based on the patterns we need to emphasize for whichever problem we are solving. In a sense, an object in human perception is just one way of viewing the world. OO forces us to pick just one 'model' and entrench it in our program. The use of stateful objects and encapsulation both prevent us from effectively supporting multiple 'views' by functional or logical transforms. In a very real sense, objects are often 'intuitive' in a bad way that can easily lead us to error. 

Arguments Against OOP: The discussion here suggests that Object-Oriented Programming (OOP) doesn't match how the human mind works. The human mind is flexible, capable of holding multiple views or models of a situation at once. OOP, however, forces programmers to pick one model and stick with it. Using stateful objects and encapsulation in OOP can hinder the ability to support multiple perspectives or transformations easily.
Key Points:

    Human Flexibility: Our minds can handle multiple ways of thinking about a problem, but OOP typically forces a single model.

    Stateful Objects: Encapsulation and statefulness in OOP can limit the flexibility needed for various views.

    Intuition Can Mislead: Objects might seem intuitive but can lead to errors if they don't match the problem's nature.

    Cultural and Experience Impact: How natural OOP feels to a person can depend on their cultural background and prior work experience.

The idea here is that while some people claim OOP reflects how humans think, this isn't universally true. Different people have different ways of thinking and might find other programming paradigms more intuitive or effective.


استدلال علیه OOP: بحث در اینجا نشان می دهد که برنامه نویسی شی گرا (OOP) با نحوه عملکرد ذهن انسان مطابقت ندارد. ذهن انسان منعطف است و قادر است چندین دیدگاه یا مدل از یک موقعیت را به طور همزمان داشته باشد. با این حال، OOP برنامه نویسان را مجبور می کند که یک مدل را انتخاب کنند و به آن پایبند باشند. استفاده از اشیاء حالت‌بندی و کپسوله‌سازی در OOP می‌تواند مانع از توانایی پشتیبانی از چندین دیدگاه یا تبدیل به راحتی شود.
نکات کلیدی:

 انعطاف پذیری انسانی: ذهن ما می تواند راه های متعددی را برای تفکر در مورد یک مشکل مدیریت کند، اما OOP معمولاً یک مدل واحد را مجبور می کند.

 اشیاء Stateful: کپسوله سازی و حالت در OOP می تواند انعطاف پذیری مورد نیاز برای نماهای مختلف را محدود کند.

 شهود می تواند گمراه کند: اشیا ممکن است بصری به نظر برسند اما اگر با ماهیت مشکل مطابقت نداشته باشند می توانند منجر به خطا شوند.

 تأثیر فرهنگی و تجربی: اینکه چه حس طبیعی OOP برای یک فرد دارد می تواند به پیشینه فرهنگی و تجربه کاری قبلی او بستگی داشته باشد.

ایده در اینجا این است که در حالی که برخی افراد ادعا می کنند که OOP نحوه تفکر انسان ها را منعکس می کند، این به طور کلی درست نیست. افراد مختلف روش‌های متفاوتی برای تفکر دارند و ممکن است پارادایم‌های برنامه‌نویسی دیگر را بصری‌تر یا مؤثرتر ببینند.


## Is Go an object-oriented language?

Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes).

Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java.


https://go.dev/doc/faq#Is_Go_an_object-oriented_language

## OOP’s in Go

Go is not a pure object-oriented language like Java or Python, but it does support object-oriented programming concepts. Go does not have classes, but it has structs, which are similar to classes in other languages. Go also supports methods on structs, which are similar to methods in classes.

Go does not have inheritance, but it has composition, which is a way to combine structs to create more complex types. Go also supports interfaces, which are similar to abstract classes in other languages.

https://medium.com/@amren1254/oops-in-go-36b40a8d1b4d


## Go Program

```
go mod init
go mod tidy
```


## Go Struct

A struct (short for structure) is used to create a collection of members of different data types, into a single variable.

While arrays are used to store multiple values of the same data type into a single variable, structs are used to store multiple values of different data types into a single variable.

A struct can be useful for grouping data together to create records.

https://www.w3schools.com/go/go_struct.php

```go
type struct_name struct {
  member1 datatype;
  member2 datatype;
  member3 datatype;
  ...
} 
```

```go
type Person struct {
  name string
  age int
  job string
  salary int
}
```


## Methods

Go does not have classes. However, you can define methods on types.

A method is a function with a special receiver argument.

The receiver appears in its own argument list between the func keyword and the method name.

In this example, the Abs method has a receiver of type Vertex named v.

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
}
```

https://go.dev/tour/methods/1

## Why golang doesn't have class

Go doesn't have classes. Instead, Go's type system provides the ability to define methods on types. Methods are a way to add behavior to types.

Go is a deliberately designed language that emphasizes simplicity, efficiency, and clarity. Here are some reasons why Go doesn't have classes:
Composition Over Inheritance:

 Go به جای وراثت از ترکیب استفاده می کند. شما می توانید انواع پیچیده را با ترکیب انواع کوچکتر به جای ارث بردن از یک کلاس پایه بسازید.


    Go uses composition instead of inheritance. You can build complex types by composing smaller types rather than inheriting from a base class.

Interfaces and Structs:

    Structs: Go uses structs to define and organize data. Structs are lightweight and flexible.

    Interfaces: Interfaces in Go are used to define methods that types must implement, promoting loose coupling and more flexible code design.

Simplified Syntax:

    Go aims to reduce complexity and avoid the pitfalls of inheritance-based designs, like the "diamond problem". The focus is on clear and maintainable code.

Easier Concurrency:

    Go's design is influenced by the need for concurrent programming, using goroutines and channels for efficient and straightforward concurrency.



## Package names

https://go.dev/blog/package-names

Here's a simple summary of the key points about Go package naming from the article:

Package Names Should Be:


Short and clear
Lowercase, no underscores or mixed caps
Often simple nouns (like "time", "list", "http")


Main Guidelines:


Avoid repetitive names in package contents
Don't use generic names like "util" or "common"
Don't steal common variable names (use "bufio" instead of "buf")
Package paths typically end with the package name


Good Examples:


"fmt" for formatted I/O
"strconv" for string conversion
"http" for HTTP functionality


What to Avoid:


Meaningless package names (util, common, misc)
Large generic packages that do many unrelated things
Putting all APIs in a single package
Names that collide with popular standard packages

The main goal is to make code easy to understand and maintain through clear, purposeful package naming.


## Go Style Decisions

This document contains style decisions intended to unify and provide standard guidance, explanations, and examples for the advice given by the Go readability mentors.

This document is not exhaustive and will grow over time. In cases where the core style guide contradicts the advice given here, the style guide takes precedence, and this document should be updated accordingly.

See the Overview for the full set of Go Style documents.

The following sections have moved from style decisions to another part of the guide:

    MixedCaps: see guide#mixed-caps

    Formatting: see guide#formatting

    Line Length: see guide#line-length

https://google.github.io/styleguide/go/decisions.html
